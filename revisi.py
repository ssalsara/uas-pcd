# -*- coding: utf-8 -*-
"""revisi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lS7ybHBwqXQVhRN7q-Iu--GE8cBEN2IF
"""

import zipfile
import os

zip_paths = {
    "Normal": "Normal (224).zip",
    "TB": "TB.533.zip"
}

extract_folders = {
    "Normal": "Normal",
    "TB": "TB"
}

for label, zip_path in zip_paths.items():
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        os.makedirs(extract_folders[label], exist_ok=True)
        zip_ref.extractall(extract_folders[label])

import matplotlib.pyplot as plt
import cv2
import os

normal_dir = "Normal"
tb_dir = "TB"

sample_size = 1
normal_list = os.listdir(normal_dir)
tb_list = os.listdir(tb_dir)
normal_images = normal_list[:sample_size]
tb_images = tb_list[:sample_size]

def plot_images(image_paths, title, folder):
    plt.figure(figsize=(10, 5))
    for i, img_name in enumerate(image_paths):
        img_path = os.path.join(folder, img_name)
        img = cv2.imread(img_path)
        if img is not None:
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            plt.subplot(2, sample_size * 2, i + 1)
            plt.imshow(img)
            plt.title(f"{title}: {img_name}")
            plt.axis("off")
    plt.tight_layout()
    plt.show()

# gambar Normal dan TB
plot_images(normal_images, "Normal", normal_dir)
plot_images(tb_images, "TBC", tb_dir)

import cv2
import os

def resize_and_save(input_folder, output_folder, size=(224, 224)):
    os.makedirs(output_folder, exist_ok=True)

    for filename in os.listdir(input_folder):
        img_path = os.path.join(input_folder, filename)
        img = cv2.imread(img_path)
        if img is not None:
            resized_img = cv2.resize(img, size)
            save_path = os.path.join(output_folder, filename)
            cv2.imwrite(save_path, resized_img)

resize_and_save("Normal", "Normal_resized")
resize_and_save("TB", "TB_resized")
# gambar Normal dan TB
plot_images(normal_images, 'Normal',"Normal_resized")
plot_images(tb_images, "TB", "TB_resized")

def grayscale_and_save(input_folder, output_folder):
    os.makedirs(output_folder, exist_ok=True)

    for filename in os.listdir(input_folder):
        img_path = os.path.join(input_folder, filename)
        img = cv2.imread(img_path)
        if img is not None:
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            save_path = os.path.join(output_folder, filename)
            cv2.imwrite(save_path, gray)

grayscale_and_save("Normal_resized", "Normal_gray")
grayscale_and_save("TB_resized", "TB_gray")

def plot_gray_images(image_paths, title, folder):
    plt.figure(figsize=(10, 5))
    for i, img_name in enumerate(image_paths):
        img_path = os.path.join(folder, img_name)
        img = cv2.imread(img_path)
        if img is not None:
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
            plt.subplot(2, sample_size * 2, i + 1)
            plt.imshow(img)
            plt.title(f"{title}: {img_name}")
            plt.axis("off")
    plt.tight_layout()
    plt.show()

plot_gray_images(normal_images, "Normal Grayscale", "Normal_gray")
plot_gray_images(tb_images, "TB Grayscale", "TB_gray")

import os
import cv2
import numpy as np

def autocrop_and_save(input_folder, output_folder_thresh, output_folder_eroded, output_folder_dilated,
                      output_folder_contours, output_folder_crop, padding=20, min_contour_area=50):
    os.makedirs(output_folder_thresh, exist_ok=True)
    os.makedirs(output_folder_eroded, exist_ok=True)
    os.makedirs(output_folder_dilated, exist_ok=True)
    os.makedirs(output_folder_contours, exist_ok=True)
    os.makedirs(output_folder_crop, exist_ok=True)

    for filename in os.listdir(input_folder):
        img_path = os.path.join(input_folder, filename)
        img_gray = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        if img_gray is not None:
            # Threshold untuk memisahkan paru
            _, thresh = cv2.threshold(img_gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

            # Erosi dan dilasi untuk memperjelas bentuk objek
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
            eroded = cv2.erode(thresh, kernel, iterations=1)
            dilated = cv2.dilate(eroded, kernel, iterations=3)

            # kontur
            contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            img_contour = np.zeros_like(cv2.cvtColor(img_gray, cv2.COLOR_GRAY2BGR))
            cv2.drawContours(img_contour, contours, -1, (0, 255, 0), 2)

            # kontur area terbesar
            ca_max = 0
            x, y, w, h = 0, 0, 0, 0
            for contour in contours:
                ca = cv2.contourArea(contour)
                if ca > min_contour_area and ca > ca_max:
                    ca_max = ca
                    x, y, w, h = cv2.boundingRect(contour)

            # crop untuk objek yang besar
                if ca_max > 0:
                    x_pad = max(x - padding, 0)
                    y_pad = max(y - padding, 0)
                    w_pad = min(w + 2 * padding, img_gray.shape[1] - x_pad)
                    h_pad = min(h + 2 * padding, img_gray.shape[0] - y_pad)

                    # buat mask
                    dilated_roi = dilated[y_pad:y_pad + h_pad, x_pad:x_pad + w_pad]
                    grayscale_roi = img_gray[y_pad:y_pad + h_pad, x_pad:x_pad + w_pad]
                    mask_hitammu = (dilated_roi == 0).astype(np.uint8) * 255

                    # ganti ke grayscale dari hasil dilasi
                    cropped_img = cv2.bitwise_and(grayscale_roi, grayscale_roi, mask=mask_hitammu)
                else:

                    y_pad = img_gray.shape[0] // 4
                    h_pad = img_gray.shape[0] * 3 // 4
                    cropped_img = img_gray[y_pad:y_pad + h_pad, :]

            cv2.imwrite(os.path.join(output_folder_thresh, filename), thresh)
            cv2.imwrite(os.path.join(output_folder_eroded, filename), eroded)
            cv2.imwrite(os.path.join(output_folder_dilated, filename), dilated)
            cv2.imwrite(os.path.join(output_folder_contours, filename), img_contour)
            cv2.imwrite(os.path.join(output_folder_crop, filename), cropped_img)

output_thresh_tb = 'TB_thresh'
output_eroded_tb = 'TB_eroded'
output_dilated_tb = 'TB_dilated'
output_contours_tb = 'TB_contours'
output_crop_tb = 'TB_crop'

autocrop_and_save('TB_gray', output_thresh_tb, output_eroded_tb, output_dilated_tb, output_contours_tb, output_crop_tb)

def plot_ted_images(image_paths, title, folder_thresh, folder_eroded, folder_dilated, folder_contours, folder_crop):
    plt.figure(figsize=(20, 10))
    for i, img_name in enumerate(image_paths):
        img_path_thresh = os.path.join(folder_thresh, img_name)
        img_path_eroded = os.path.join(folder_eroded, img_name)
        img_path_dilated = os.path.join(folder_dilated, img_name)
        img_path_contours = os.path.join(folder_contours, img_name)
        img_path_crop = os.path.join(folder_crop, img_name)

        img_thresh = cv2.imread(img_path_thresh, cv2.IMREAD_GRAYSCALE)
        img_eroded = cv2.imread(img_path_eroded, cv2.IMREAD_GRAYSCALE)
        img_dilated = cv2.imread(img_path_dilated, cv2.IMREAD_GRAYSCALE)
        img_contours = cv2.imread(img_path_contours, cv2.IMREAD_GRAYSCALE)
        img_crop = cv2.imread(img_path_crop, cv2.IMREAD_GRAYSCALE)

        if img_thresh is not None and img_eroded is not None and img_dilated is not None:
            plt.subplot(1, 5, 1)
            plt.imshow(img_thresh, cmap='gray')
            plt.title(f'{title}: {img_name}Thresholding')
            plt.axis('off')

            plt.subplot(1, 5, 2)
            plt.imshow(img_eroded, cmap='gray')
            plt.title(f'{title}: {img_name} Erode')
            plt.axis('off')

            plt.subplot(1, 5, 3)
            plt.imshow(img_dilated, cmap='gray')
            plt.title(f'{title}: {img_name} Dilate')
            plt.axis('off')

            plt.subplot(1, 5, 4)
            plt.imshow(img_contours)
            plt.title(f'{title}: {img_name} Kontur')
            plt.axis('off')

            plt.subplot(1, 5, 5)
            plt.imshow(img_crop, cmap='gray')
            plt.title(f'{title}: {img_name} Cropped')
            plt.axis('off')

plot_ted_images(tb_images, "TB", output_thresh_tb, output_eroded_tb, output_dilated_tb, output_contours_tb, output_crop_tb)

import os
import cv2
import numpy as np

def autocrop_and_save(input_folder, output_folder_thresh, output_folder_eroded, output_folder_dilated,
                      output_folder_contours, output_folder_crop, padding=20, min_contour_area=50):
    os.makedirs(output_folder_thresh, exist_ok=True)
    os.makedirs(output_folder_eroded, exist_ok=True)
    os.makedirs(output_folder_dilated, exist_ok=True)
    os.makedirs(output_folder_contours, exist_ok=True)
    os.makedirs(output_folder_crop, exist_ok=True)

    for filename in os.listdir(input_folder):
        img_path = os.path.join(input_folder, filename)
        img_gray = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        if img_gray is not None:
            # Threshold
            _, thresh = cv2.threshold(img_gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

            # Erosi dan dilasi untuk memperjelas bentuk objek
            kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
            eroded = cv2.erode(thresh, kernel, iterations=3)
            dilated = cv2.dilate(eroded, kernel, iterations=3)

            # kontur
            contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            img_contour = np.zeros_like(cv2.cvtColor(img_gray, cv2.COLOR_GRAY2BGR))
            cv2.drawContours(img_contour, contours, -1, (0, 255, 0), 2)

            # area terbesar
            ca_max = 0
            x, y, w, h = 0, 0, 0, 0
            for contour in contours:
                ca = cv2.contourArea(contour)
                if ca > min_contour_area and ca > ca_max:
                    ca_max = ca
                    x, y, w, h = cv2.boundingRect(contour)

                if ca_max > 0:
                    x_pad = max(x - padding, 0)
                    y_pad = max(y - padding, 0)
                    w_pad = min(w + 2 * padding, img_gray.shape[1] - x_pad)
                    h_pad = min(h + 2 * padding, img_gray.shape[0] - y_pad)

                    dilated_roi = dilated[y_pad:y_pad + h_pad, x_pad:x_pad + w_pad]
                    grayscale_roi = img_gray[y_pad:y_pad + h_pad, x_pad:x_pad + w_pad]
                    mask_hitammu = (dilated_roi == 0).astype(np.uint8) * 255
                    cropped_img = cv2.bitwise_and(grayscale_roi, grayscale_roi, mask=mask_hitammu)
                else:
                    y_pad = img_gray.shape[0] // 4
                    h_pad = img_gray.shape[0] * 3 // 4
                    cropped_img = img_gray[y_pad:y_pad + h_pad, :]

            cv2.imwrite(os.path.join(output_folder_thresh, filename), thresh)
            cv2.imwrite(os.path.join(output_folder_eroded, filename), eroded)
            cv2.imwrite(os.path.join(output_folder_dilated, filename), dilated)
            cv2.imwrite(os.path.join(output_folder_contours, filename), img_contour)
            cv2.imwrite(os.path.join(output_folder_crop, filename), cropped_img)
output_thresh_normal = 'Normal_thresh'
output_eroded_normal = 'Normal_eroded'
output_dilated_normal = 'Normal_dilated'
output_contours_normal = 'Normal_contours'
output_crop_normal = 'Normal_crop'

autocrop_and_save('Normal_gray', output_thresh_normal, output_eroded_normal, output_dilated_normal, output_contours_normal, output_crop_normal)

def plot_ted_images(image_paths, title, folder_thresh, folder_eroded, folder_dilated, folder_contours, folder_crop):
    plt.figure(figsize=(20, 10))
    for i, img_name in enumerate(image_paths):
        img_path_thresh = os.path.join(folder_thresh, img_name)
        img_path_eroded = os.path.join(folder_eroded, img_name)
        img_path_dilated = os.path.join(folder_dilated, img_name)
        img_path_contours = os.path.join(folder_contours, img_name)
        img_path_crop = os.path.join(folder_crop, img_name)

        img_thresh = cv2.imread(img_path_thresh, cv2.IMREAD_GRAYSCALE)
        img_eroded = cv2.imread(img_path_eroded, cv2.IMREAD_GRAYSCALE)
        img_dilated = cv2.imread(img_path_dilated, cv2.IMREAD_GRAYSCALE)
        img_contours = cv2.imread(img_path_contours, cv2.IMREAD_GRAYSCALE)
        img_crop = cv2.imread(img_path_crop, cv2.IMREAD_GRAYSCALE)

        if img_thresh is not None and img_eroded is not None and img_dilated is not None:
            plt.subplot(1, 5, 1)
            plt.imshow(img_thresh, cmap='gray')
            plt.title(f'{title}: {img_name}Thresholding')
            plt.axis('off')

            plt.subplot(1, 5, 2)
            plt.imshow(img_eroded, cmap='gray')
            plt.title(f'{title}: {img_name} Erode')
            plt.axis('off')

            plt.subplot(1, 5, 3)
            plt.imshow(img_dilated, cmap='gray')
            plt.title(f'{title}: {img_name} Dilate')
            plt.axis('off')

            plt.subplot(1, 5, 4)
            plt.imshow(img_contours)
            plt.title(f'{title}: {img_name} Kontur')
            plt.axis('off')

            plt.subplot(1, 5, 5)
            plt.imshow(img_crop, cmap='gray')
            plt.title(f'{title}: {img_name} Cropped')
            plt.axis('off')


plot_ted_images(normal_images, "Normal", output_thresh_normal, output_eroded_normal, output_dilated_normal, output_contours_normal, output_crop_normal)

def median_filter_and_save(input_folder, output_folder, ksize=3):
    os.makedirs(output_folder, exist_ok=True)

    for filename in os.listdir(input_folder):
        img_path = os.path.join(input_folder, filename)
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        if img is not None:
            median = cv2.medianBlur(img, ksize)
            save_path = os.path.join(output_folder, filename)
            cv2.imwrite(save_path, median)

median_filter_and_save("Normal_crop", "Normal_median")
median_filter_and_save("TB_crop", "TB_median")

def plot_median_images(image_paths, title, folder):
    plt.figure(figsize=(10, 5))
    for i, img_name in enumerate(image_paths):
        img_path = os.path.join(folder, img_name)
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        if img is not None:
            plt.subplot(2, len(image_paths)*2, i+1)
            plt.imshow(img, cmap='gray')
            plt.title(f"{title}: {img_name}")
            plt.axis("off")
    plt.tight_layout()
    plt.show()

plot_median_images(normal_images, "Normal Median", "Normal_median")
plot_median_images(tb_images, "TB Median", "TB_median")

def heq_and_save(input_folder, output_folder_heq):
    os.makedirs(output_folder_heq, exist_ok=True)

    for filename in os.listdir(input_folder):
        img_path = os.path.join(input_folder, filename)
        img_gray = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        if img_gray is not None:
            contrast_v1 = cv2.equalizeHist(img_gray)
            save_path = os.path.join(output_folder_heq, filename)
            cv2.imwrite(save_path, contrast_v1)

heq_and_save("Normal_median", "Normal_heq")
heq_and_save("TB_median", "TB_heq")
def plot_heq_save(image_paths, title, folder):
    plt.figure(figsize=(10, 5))
    for i, img_name in enumerate(image_paths):
        img_path = os.path.join(folder, img_name)
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        if img is not None:
            plt.subplot(2, len(image_paths), i + 1)
            plt.imshow(img, cmap='gray')
            plt.title(f"{title}: {img_name}")
            plt.axis("off")
    plt.tight_layout()
    plt.show()

plot_heq_save(normal_images, "Normal HEQ", "Normal_heq")
plot_heq_save(tb_images, "TB HEQ", "TB_heq")

import pywt
def apply_clahe_to_high_freq(LH, HL, HH, clip_limit=0.01):
    clahe = cv2.createCLAHE(clipLimit=clip_limit, tileGridSize=(8,8))
    enhanced_LH = clahe.apply(LH.astype(np.uint8)).astype(np.float32)
    enhanced_HL = clahe.apply(HL.astype(np.uint8)).astype(np.float32)
    enhanced_HH = clahe.apply(HH.astype(np.uint8)).astype(np.float32)

    return enhanced_LH, enhanced_HL, enhanced_HH

def denoise_image_with_dwt_high_freq_clahe(input_image, level=1, clip_limit=0.01):
    coeffs = pywt.wavedec2(input_image, 'coif2', level=level)
    cA = coeffs[0]
    cD_list = coeffs[1:]

    enhanced_detail = []
    for (LH, HL, HH) in cD_list:
        # normalisasi ke 0-255
        LH_norm = cv2.normalize(LH, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
        HL_norm = cv2.normalize(HL, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
        HH_norm = cv2.normalize(HH, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

        # CLAHE
        e_LH, e_HL, e_HH = apply_clahe_to_high_freq(LH_norm, HL_norm, HH_norm, clip_limit)

        # kembalikan ke float32 dan skala ke kisaran asli
        e_LH = e_LH.astype(np.float32) / 255 * (LH.max() - LH.min()) + LH.min()
        e_HL = e_HL.astype(np.float32) / 255 * (HL.max() - HL.min()) + HL.min()
        e_HH = e_HH.astype(np.float32) / 255 * (HH.max() - HH.min()) + HH.min()

        enhanced_detail.append((e_LH, e_HL, e_HH))

    new_coeffs = [cA] + enhanced_detail

    # Rekonstruksi citra
    reconstructed_img = pywt.waverec2(new_coeffs, 'coif2')

    # Clip dan konversi ke uint8
    reconstructed_img = np.clip(reconstructed_img, 0, 255).astype(np.uint8)

    return reconstructed_img

def apply_dwt_high_clahe_and_save(input_folder, output_folder, level=1, clip_limit=0.01):
    os.makedirs(output_folder, exist_ok=True)

    for filename in os.listdir(input_folder):
        img_path = os.path.join(input_folder, filename)
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        if img is not None:
            processed_img = denoise_image_with_dwt_high_freq_clahe(img, level=level, clip_limit=clip_limit)
            save_path = os.path.join(output_folder, filename)
            cv2.imwrite(save_path, processed_img)

apply_dwt_high_clahe_and_save("Normal_heq", "Normal_highfreq_clahe", level=2, clip_limit=0.01)
apply_dwt_high_clahe_and_save("TB_heq", "TB_highfreq_clahe", level=2, clip_limit=0.01)

def plot_dwt_clahe_images(image_paths, title, folder):
    plt.figure(figsize=(10, 5))
    for i, img_name in enumerate(image_paths):
        img_path = os.path.join(folder, img_name)
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
        if img is not None:
            plt.subplot(2, len(image_paths), i + 1)
            plt.imshow(img, cmap='gray')
            plt.title(f"{title}: {img_name}")
            plt.axis("off")
    plt.tight_layout()
    plt.show()

plot_dwt_clahe_images(normal_images, "Normal DWT-CLAHE", "Normal_highfreq_clahe")
plot_dwt_clahe_images(tb_images, "TB DWT-CLAHE", "TB_highfreq_clahe")

from skimage.transform import resize
from skimage.io import imread
from sklearn import svm
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report

categories = ["Normal_highfreq_clahe", "TB_highfreq_clahe"]
flat_data = []
target = []
data_dir = "C:/SALSA'S STUDY/SEM 4/PCD"
for category in categories:
  print(f'loading category: {category}')
  path = os.path.join(data_dir, category)
  for img in os.listdir(path):
    img_array = cv2.imread(os.path.join(path, img), cv2.IMREAD_GRAYSCALE)
    img_resized = resize(img_array, (150, 150))
    flat_data.append(img_resized.flatten())
    target.append(categories.index(category))
  print(f'loaded category: {category} successfully')

flat_data = np.array(flat_data)
target = np.array(target)

import pandas as pd
df = pd.DataFrame(flat_data)
df['Target'] = target
df.head()

X = df.drop('Target', axis=1)
y = df['Target']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

X.head()

y.head()

# Menampilkan jumlah setiap train test
train_category_counts = y_train.value_counts()
test_category_counts = y_test.value_counts()
print("Jumlah setiap data untuk train:")
print(train_category_counts)
print("\nJumlah setiap data untuk test:")
print(test_category_counts)

# deploy
import joblib
import streamlit as st
svc = svm.SVC(probability=True)
svc.fit(X_train, y_train)
joblib.dump(svc, 'svm_model.joblib')

accuracy = svc.score(X_test, y_test)
print(f'Support Vector Machine Accuracy: {accuracy}')

y_pred = svc.predict(X_test)
st.text(classification_report(y_test, y_pred, target_names=["Normal", "TBC"] ))

def predict_image(image, model, size=(150,150)):
    if image is not None:
        gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        img_resized = resize(gray_image, size)
        flat_data = img_resized.flatten().reshape(1, -1)
        pred_prob = model.predict_proba(flat_data)[0]
        pred_class = model.predict(flat_data)[0]
        return pred_class, pred_prob
    return None, None

st.title('TB Detection')
model = joblib.load('svm_model.joblib')
uploaded_file = st.file_uploader('Upload an image', type=['jpg', 'jpeg', 'png'])
if uploaded_file is not None:
    image = cv2.imdecode(np.fromstring(uploaded_file.read(), np.uint8), 1)
    st.image(image, caption="Gambar yang diunggah", use_column_width=True)
    pred_class, pred_prob = predict_image(image, model)
    if pred_class is not None:
        classes = ["Normal", "TBC"]
        st.write(f"Prediksi: **{classes[pred_class]}**")
        st.write(f'probabilitas: Normal = {pred_prob[0]}, TBC = {pred_prob[1]:.2f}')